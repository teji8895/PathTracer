{"version":3,"sources":["Node/Node.jsx","Algorithms/Dijkstra.js","Algorithms/Astar.js","Algorithms/DFS.js","Algorithms/BFS.js","Algorithms/Biderectional.js","PathFindingVisualizer/PathFindingVisualizer.jsx","App.js","index.js"],"names":["Node","this","props","column","isFinish","isStart","isWall","row","onMouseUp","onMouseDown","onMouseEnter","isVisited","extraClassName","id","className","React","Component","updateUnvisitedNeighbours","node","grid","unvistedNeighbours","getUnvisitedNeighbours","neighbour","distance","previousNode","neighbours","push","length","filter","sortAllNodes","unvisitedNodes","sort","nodeA","nodeB","getAllNodes","nodes","getNodesInShortestPath","finishNode","getShortestPath","currentNode","unshift","heuristic","Math","abs","removeArray","arr","val","i","splice","getUnvisitedFreeNeigbours","PathFindingVisulaizer","state","mouseIsPressed","start","end","startPointPressed","finishPointPresed","algoValue","handleChange","bind","handleSubmit","event","alert","setState","target","value","preventDefault","visualizeDijskhtra","visualizeAStar","visualizeDFS","visualizeBFS","visualizeBidirectional","newGrid","GetNewWallsGrid","newStart","GetNewStartPoints","newEnd","GetNewFinishPoints","newgrid","getInitialGrid","document","getElementById","visitedNodesInOrder","getShortestPathInOrder","setTimeout","j","nodeInShortestPath","startNode","visitedNodesinOrder","closestNode","shift","Infinity","dijkstra","animateDijkstra","openSet","closedSet","winner","fscore","current","tempG","newPath","includes","Astar","structure","visitedNodes","pop","dfs","queue","neigbours","bfs","queueforward","queuebackward","traceNode","visitedBy","traceBiNode","currentNode1","console","log","neigbours1","neighbour1","bidirectional","lastelement","lastSecondelement","getBiPath","onSubmit","onChange","type","onClick","clearGrid","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.0a1b7565.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Node.css'\r\n\r\nclass Node extends React.Component{\r\n\r\n    render()\r\n    {\r\n        \r\n        const{column,isFinish,isStart,isWall,row,onMouseUp,onMouseDown,onMouseEnter,isVisited}=this.props;\r\n        \r\n        const extraClassName = isFinish? 'node-finish':\r\n                               isStart?  'node-start' :\r\n                               isWall?   'node-wall':\r\n                               !isVisited? '..':\r\n                               '';\r\n       \r\n        return (\r\n\r\n            <div\r\n\r\n            id={`Node -${row}-${column}`}\r\n            className={`Node ${extraClassName}`}\r\n            onMouseDown={()=> onMouseDown(row,column)}\r\n            onMouseEnter={()=> onMouseEnter(row,column)}\r\n            onMouseUp={()=> onMouseUp(row,column)}\r\n\r\n            ></div>\r\n        );\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nexport default Node;","\r\nexport function dijkstra(grid,startNode,finishNode)\r\n{\r\n const visitedNodesinOrder=[];\r\n startNode.distance=0;\r\n const unvisitedNodes=getAllNodes(grid);\r\n while (!!unvisitedNodes.length)\r\n {\r\n    sortAllNodes(unvisitedNodes);\r\n    const closestNode=unvisitedNodes.shift();\r\n\r\n    if(closestNode.isWall) continue;\r\n\r\n    if(closestNode.distance===Infinity) return visitedNodesinOrder;\r\n\r\n    closestNode.isVisited=true;\r\n\r\n    visitedNodesinOrder.push(closestNode);\r\n\r\n    if(closestNode===finishNode) return visitedNodesinOrder;\r\n\r\n    updateUnvisitedNeighbours(closestNode,grid);\r\n }\r\n\r\n\r\n}\r\n\r\n\r\nconst updateUnvisitedNeighbours=(node,grid)=>{\r\n\r\n    const unvistedNeighbours=getUnvisitedNeighbours(node,grid);\r\n\r\n\r\n    for(const neighbour of unvistedNeighbours)\r\n    {\r\n         neighbour.distance=node.distance+1;\r\n         neighbour.previousNode=node;\r\n    }\r\n\r\n    return unvistedNeighbours;\r\n\r\n}\r\n\r\nconst getUnvisitedNeighbours=(node,grid)=>\r\n{\r\n\r\n    const neighbours=[];\r\n\r\n    const{row,column}=node;\r\n\r\n    if(row>0) neighbours.push(grid[row-1][column]);\r\n    \r\n    if(row<grid.length-1) neighbours.push(grid[row+1][column]);\r\n\r\n    if(column>0) neighbours.push(grid[row][column-1]);\r\n\r\n    if(column<grid[0].length-1) neighbours.push(grid[row][column+1]);\r\n\r\n\r\n    return neighbours.filter(neighbour=> !neighbour.isVisited);\r\n}\r\n\r\nconst sortAllNodes=(unvisitedNodes)=>{\r\n\r\n    unvisitedNodes.sort((nodeA,nodeB)=> nodeA.distance-nodeB.distance);\r\n}\r\n\r\n\r\n\r\nconst getAllNodes=(grid)=>{\r\n    const nodes=[];\r\n\r\n    for(const row of grid)\r\n    {\r\n        for(const node of row)\r\n        {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPath(finishNode){\r\n\r\nconst getShortestPath=[];\r\nlet currentNode=finishNode;\r\n\r\nwhile (currentNode!==null)\r\n{\r\n    getShortestPath.unshift(currentNode);\r\n    currentNode=currentNode.previousNode;\r\n}\r\n\r\nreturn getShortestPath;\r\n}\r\n\r\n\r\n","\r\nexport function Astar(grid,startNode,finishNode){\r\n\r\n  let openSet=[];\r\n  let closedSet=[];\r\n startNode.distance=0;\r\n  openSet.push(startNode);\r\n\r\n  while(!!openSet.length)\r\n  {\r\n     let winner=0;\r\n     for(let i=0;i<openSet.length;i++)\r\n     {\r\n        if(openSet[i].fscore<openSet[winner].fscore)\r\n        {\r\n            winner=i;\r\n        }\r\n     }\r\n\r\n     let current=openSet[winner];\r\n\r\n     if(current.isWall)\r\n     {\r\n\r\n        openSet=removeArray(openSet,current); \r\n        continue;\r\n     }\r\n\r\n     \r\n     current.isVisited=true;\r\n\r\n     if(current===finishNode)\r\n     {\r\n        \r\n         return closedSet;\r\n     }\r\n\r\n     \r\n\r\n    openSet=removeArray(openSet,current);    \r\n\r\n     \r\n\r\n    closedSet.push(current);\r\n     \r\n    const unvistedNeighbours=getUnvisitedNeighbours(current,grid);\r\n\r\n    for(const neighbour of unvistedNeighbours)\r\n    {   \r\n\r\n            \r\n            var tempG=current.distance + 1;\r\n\r\n            var newPath=false;\r\n\r\n            if(openSet.includes(neighbour))\r\n            {\r\n                if(tempG<neighbour.distance){\r\n                    neighbour.distance=tempG;\r\n                    newPath=true;\r\n                }\r\n            }\r\n            else{\r\n                neighbour.distance=tempG;\r\n\r\n                newPath=true;\r\n                openSet.push(neighbour);\r\n            }\r\n        \r\n            if(newPath)\r\n            {\r\n            neighbour.heuristic=heuristic(neighbour,finishNode);\r\n            neighbour.fscore=neighbour.distance+neighbour.heuristic;\r\n            neighbour.previousNode=current;\r\n            }\r\n        \r\n    }\r\n\r\n    \r\n\r\n  }\r\n\r\n  return closedSet;\r\n\r\n}\r\n\r\n\r\n\r\n\r\nfunction heuristic(neighbour, finishNode)\r\n{\r\n   var d=Math.abs(neighbour.row-finishNode.row) + Math.abs(neighbour.column-finishNode.column);\r\n   \r\n    return d;\r\n}\r\n\r\n\r\nconst getUnvisitedNeighbours=(node,grid)=>\r\n{\r\n\r\n    const neighbours=[];\r\n\r\n    const{row,column}=node;\r\n\r\n    if(row>0) neighbours.push(grid[row-1][column]);\r\n    \r\n    if(row<grid.length-1) neighbours.push(grid[row+1][column]);\r\n\r\n    if(column>0) neighbours.push(grid[row][column-1]);\r\n\r\n    if(column<grid[0].length-1) neighbours.push(grid[row][column+1]);\r\n\r\n\r\n    return neighbours.filter(neighbour=> !neighbour.isVisited) ;\r\n}\r\n\r\nconst removeArray=(arr,val)=>{\r\n\r\n    for(var i=arr.length-1;i>=0;i--)\r\n    {\r\n\r\n        if(arr[i]===val){\r\n            arr.splice(i,1);\r\n        }\r\n\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\nexport function getNodesInShortestPath(finishNode){\r\n\r\n    const getShortestPath=[];\r\n    let currentNode=finishNode;\r\n    \r\n    while (currentNode!==null)\r\n    {\r\n        getShortestPath.unshift(currentNode);\r\n        currentNode=currentNode.previousNode;\r\n    }\r\n    \r\n    return getShortestPath;\r\n    }","export  function dfs(grid,startNode,finishNode){\r\n\r\nlet structure=[]; \r\nconst visitedNodes=[];\r\nstructure.push(startNode);\r\n\r\nwhile(!!structure.length){\r\n    \r\n   \r\n\r\n    let currentNode=structure.pop();\r\n\r\n    //console.log(currentNode);\r\n\r\n    currentNode.isVisited=true;\r\n\r\n    visitedNodes.push(currentNode);\r\n\r\n    if(currentNode===finishNode){\r\n        return visitedNodes;\r\n    }\r\n\r\n    let neighbours=getUnvisitedFreeNeigbours(currentNode,grid);\r\n\r\n   \r\n    \r\n\r\n    for(const neighbour of neighbours){\r\n\r\n        structure.push(neighbour);\r\n        neighbour.previousNode=currentNode;\r\n\r\n    }\r\n\r\n    \r\n   \r\n}\r\n\r\nreturn visitedNodes;\r\n\r\n}\r\n\r\nconst getUnvisitedFreeNeigbours=(node,grid)=>\r\n{\r\n\r\n    const neighbours=[];\r\n\r\n    const{row,column}=node;\r\n\r\n    \r\n     //up\r\n     if(row>0) neighbours.unshift(grid[row-1][column]);\r\n\r\n     //right\r\n    if(column<grid[0].length-1) neighbours.unshift(grid[row][column+1]);\r\n\r\n     //down\r\n     if(row<grid.length-1) neighbours.unshift(grid[row+1][column]);\r\n\r\n\r\n     //left\r\n    if(column>0) neighbours.unshift(grid[row][column-1]);\r\n\r\n    \r\n\r\n   \r\n\r\n\r\n    return neighbours.filter(neighbour=> !neighbour.isVisited && !neighbour.isWall);\r\n}","export function bfs(grid,startNode,finishNode){\r\n\r\n    const queue=[];\r\n    queue.push(startNode);\r\n    const visitedNodes=[];\r\n    startNode.isVisited=true;\r\n\r\n\r\n    while(!!queue.length){\r\n\r\n        let currentNode=queue.shift();\r\n\r\n        visitedNodes.push(currentNode);\r\n\r\n        if(currentNode===finishNode)\r\n        {\r\n            \r\n            return visitedNodes;\r\n            \r\n        }\r\n\r\n        let neigbours=getUnvisitedFreeNeigbours(currentNode,grid);\r\n\r\n        for(const neighbour of neigbours){\r\n\r\n            neighbour.isVisited=true;\r\n            queue.push(neighbour);\r\n            neighbour.previousNode=currentNode;\r\n\r\n\r\n        }\r\n\r\n        \r\n        \r\n\r\n }\r\n\r\n}\r\n\r\nconst getUnvisitedFreeNeigbours=(node,grid)=>\r\n{\r\n\r\n    const neighbours=[];\r\n\r\n    const{row,column}=node;\r\n    \r\n    //up\r\n     if(row>0) neighbours.push(grid[row-1][column]);\r\n\r\n     //right\r\n    if(column<grid[0].length-1) neighbours.push(grid[row][column+1]);\r\n\r\n     //down\r\n     if(row<grid.length-1) neighbours.push(grid[row+1][column]);\r\n\r\n     //left\r\n    if(column>0) neighbours.push(grid[row][column-1]);\r\n\r\n    return neighbours.filter(neighbour=> !neighbour.isVisited && !neighbour.isWall);\r\n}","export function bidirectional(grid,startNode, finishNode){\r\n\r\nconst queueforward=[];\r\nconst queuebackward=[];\r\nconst visitedNodes=[];\r\n\r\n\r\nstartNode.isVisited=true;\r\nfinishNode.isVisited=true;\r\n\r\nqueueforward.push(startNode);\r\nqueuebackward.push(finishNode);\r\nlet traceNode=null;\r\n\r\n\r\n\r\n\r\n\r\n\r\nwhile(!!queueforward.length && !!queuebackward.length){\r\n\r\n  \r\n        let currentNode=queueforward.shift();\r\n\r\n        visitedNodes.push(currentNode);\r\n\r\n        if(currentNode.visitedBy===\"backward\") {\r\n            \r\n            visitedNodes[visitedNodes.length-1].traceBiNode=traceNode;\r\n \r\n            return visitedNodes;\r\n        }\r\n        currentNode.visitedBy=\"forward\";\r\n\r\n          //visitedNodes.push(currentNode);\r\n\r\n        let neigbours=getUnvisitedFreeNeigbours(currentNode,grid);\r\n\r\n        for(const neighbour of neigbours){\r\n\r\n           \r\n            if(!neighbour.isVisited){\r\n                neighbour.isVisited=true;\r\n             \r\n                queueforward.push(neighbour);\r\n                neighbour.previousNode=currentNode;\r\n                \r\n            }\r\n            else if(neighbour.visitedBy===\"backward\"){\r\n              \r\n                queueforward.unshift(neighbour);\r\n                traceNode=currentNode;\r\n               \r\n            }\r\n            else continue;\r\n            \r\n        }\r\n    \r\n\r\n        let currentNode1=queuebackward.shift();\r\n\r\n        \r\n        \r\n      \r\n\r\n        visitedNodes.push(currentNode1);\r\n\r\n        if(currentNode1.visitedBy===\"forward\") {\r\n\r\n          \r\n            console.log(traceNode);\r\n            visitedNodes[visitedNodes.length-1].traceBiNode=traceNode;\r\n\r\n            return visitedNodes;\r\n        }\r\n        currentNode1.visitedBy=\"backward\";\r\n         \r\n       // visitedNodes.push(currentNode1);\r\n\r\n        let neigbours1=getUnvisitedFreeNeigbours(currentNode1,grid);\r\n\r\n        for(const neighbour1 of neigbours1){\r\n            if(!neighbour1.isVisited){\r\n                neighbour1.isVisited=true;\r\n                \r\n                queuebackward.push(neighbour1);\r\n                neighbour1.previousNode=currentNode1;\r\n                \r\n               \r\n            }\r\n            else if(neighbour1.visitedBy===\"forward\"){\r\n              \r\n                queuebackward.unshift(neighbour1);\r\n                traceNode=currentNode1;\r\n             \r\n            }            \r\n            else continue;\r\n        }\r\n\r\n       \r\n    \r\n\r\n}\r\n\r\nreturn visitedNodes;\r\n\r\n}\r\n \r\n\r\n\r\n\r\n\r\n\r\nconst getUnvisitedFreeNeigbours=(node,grid)=>\r\n{\r\n\r\n    const neighbours=[];\r\n\r\n    const{row,column}=node;\r\n    \r\n   \r\n\r\n     //right\r\n    if(column<grid[0].length-1) neighbours.push(grid[row][column+1]);\r\n\r\n     //down\r\n     if(row<grid.length-1) neighbours.push(grid[row+1][column]);\r\n\r\n     //left\r\n    if(column>0) neighbours.push(grid[row][column-1]);\r\n\r\n     //up\r\n     if(row>0) neighbours.push(grid[row-1][column]);\r\n\r\n    return neighbours.filter(neighbour=> !neighbour.isWall);\r\n\r\n}\r\n\r\n\r\nexport function getBiPath(startNode,finishNode,visitedNodes){\r\n\r\n    let lastelement=visitedNodes[visitedNodes.length-1];\r\n    let lastSecondelement=visitedNodes[visitedNodes.length-1].traceBiNode;\r\n    const getShortestPath=[];\r\n\r\n    if(lastelement.visitedBy===\"forward\"){\r\n        //start\r\n        while(lastelement!==null){\r\n\r\n        getShortestPath.unshift(lastelement);\r\n         lastelement=lastelement.previousNode ;  \r\n        }\r\n\r\n        while( lastSecondelement!==null){\r\n            getShortestPath.push(lastSecondelement);\r\n            lastSecondelement=lastSecondelement.previousNode;\r\n        }\r\n    }\r\n\r\n    else{\r\n        //start\r\n        while(lastelement!==null){\r\n\r\n            getShortestPath.push(lastelement);\r\n             lastelement=lastelement.previousNode ;  \r\n            }\r\n    \r\n            while( lastSecondelement!==null){\r\n                getShortestPath.unshift(lastSecondelement);\r\n                lastSecondelement=lastSecondelement.previousNode;\r\n            }\r\n\r\n\r\n\r\n    }\r\n    \r\n    return getShortestPath;\r\n    }\r\n\r\n\r\n\r\n\r\n","import React from 'react';\r\nimport './PathFinderVisualizer.css';\r\nimport Node from '../Node/Node';\r\nimport {dijkstra,getNodesInShortestPath} from '../Algorithms/Dijkstra';\r\nimport {Astar} from '../Algorithms/Astar';\r\nimport {dfs} from '../Algorithms/DFS';\r\nimport {bfs} from '../Algorithms/BFS';\r\nimport {bidirectional,getBiPath} from '../Algorithms/Biderectional';\r\n\r\nconst START_NODE_ROW=7;\r\nconst START_NODE_COL=5;\r\nconst END_NODE_ROW=5;\r\nconst END_NODE_COL=26;\r\n\r\nclass PathFindingVisulaizer extends React.Component{\r\n\r\n  \r\n\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            grid:[],\r\n            mouseIsPressed:false,\r\n            start:[START_NODE_ROW,START_NODE_COL],\r\n            end:[END_NODE_ROW,END_NODE_COL],\r\n            startPointPressed:false,\r\n            finishPointPresed:false,\r\n            algoValue:\"dijkshtra\"\r\n        };\r\n\r\n        this.handleChange=this.handleChange.bind(this);\r\n        this.handleSubmit=this.handleSubmit.bind(this);\r\n\r\n    }\r\n\r\n\r\n    //handle change of algorithm selection from the drop down\r\n    handleChange(event){\r\n\r\n        const{grid,start}=this.state;\r\n        if(grid[start[0]][start[1]].isVisited) {\r\n            alert(\"Please clear the Board and then select\");\r\n            return;\r\n        }\r\n\r\n        this.setState({algoValue: event.target.value});\r\n    }\r\n\r\n    //handle the submission of algo search post selection\r\n    handleSubmit(event){\r\n\r\n        const grid=this.state.grid;\r\n        if(grid[START_NODE_ROW][START_NODE_COL].isVisited) {\r\n            alert(\"Please clear the Board and then select\");\r\n            event.preventDefault();\r\n            return;\r\n        }\r\n\r\n        if(this.state.algoValue===\"dijkshtra\")  this.visualizeDijskhtra();\r\n        else if(this.state.algoValue===\"AStar\") this.visualizeAStar();\r\n        else if(this.state.algoValue===\"dfs\") this.visualizeDFS();\r\n        else if(this.state.algoValue===\"bfs\") this.visualizeBFS();\r\n        else if(this.state.algoValue===\"Bidirectional\") this.visualizeBidirectional();\r\n        else alert(\"Wrong Selection\");\r\n\r\n        event.preventDefault();\r\n    }\r\n\r\n\r\n    \r\n    handleMouseDown(row,column){\r\n\r\n      \r\n     \r\n        if((row===this.state.start[0] && column===this.state.start[1]))\r\n        {\r\n            \r\n            this.setState({startPointPressed:true,mouseIsPressed:true});\r\n        }\r\n        else if((row===this.state.end[0] && column===this.state.end[1]))\r\n        {\r\n            \r\n            this.setState({finishPointPresed:true,mouseIsPressed:true});\r\n        }\r\n        else{\r\n            const newGrid= GetNewWallsGrid(this.state.grid,row,column);\r\n            this.setState({grid:newGrid,mouseIsPressed:true});\r\n        }\r\n\r\n    }\r\n\r\n    handleMouseEnter(row,column){\r\n        \r\n        if(!this.state.mouseIsPressed) return;\r\n\r\n        else if(this.state.startPointPressed){\r\n\r\n            const newStart= GetNewStartPoints(this.state.start,row,column);\r\n            this.setState({start:newStart});\r\n        }   \r\n        else if(this.state.finishPointPresed){\r\n            const newEnd=GetNewFinishPoints(this.state.end,row,column);\r\n            this.setState({end:newEnd});\r\n        }\r\n        else{\r\n        const newGrid= GetNewWallsGrid(this.state.grid,row,column);\r\n        this.setState({newGrid});\r\n        }\r\n        }\r\n\r\n    \r\n\r\n\r\n    handleMouseUp(row,column){\r\n        \r\n         this.setState({mouseIsPressed:false,startPointPressed:false,finishPointPresed:false    });\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        \r\n        const newgrid=getInitialGrid();\r\n        this.setState({grid:newgrid});\r\n        \r\n       \r\n    }\r\n\r\n    \r\n         //Ignore the below code\r\n\r\n    clearGrid(){\r\n       \r\n        const newgrid=getInitialGrid();\r\n        this.setState({grid:newgrid,\r\n            start:[START_NODE_ROW,START_NODE_COL],\r\n            end:[END_NODE_ROW,END_NODE_COL],\r\n        });\r\n       \r\n        for(let row=0;row<15;row++){\r\n            \r\n            for(let column=0;column<28;column++){\r\n\r\n                if(row===START_NODE_ROW && column===START_NODE_COL){\r\n\r\n                    document.getElementById(`Node -${row}-${column}`).className='Node node-start';\r\n\r\n\r\n                }\r\n                else if(row===END_NODE_ROW && column===END_NODE_COL){\r\n                document.getElementById(`Node -${row}-${column}`).className='Node node-finish';\r\n                }\r\n\r\n                else document.getElementById(`Node -${row}-${column}`).className='Node ';\r\n\r\n\r\n            }\r\n        }\r\n\r\n      // console.log(this.state.grid);\r\n        \r\n\r\n    \r\n}\r\n\r\n    animateDijkstra(visitedNodesInOrder,getShortestPathInOrder){\r\n        \r\n        for(let i=0;i<=visitedNodesInOrder.length;i++)\r\n        {\r\n            if(i===visitedNodesInOrder.length)\r\n            {\r\n               \r\n                setTimeout(()=> {\r\n                for(let j=getShortestPathInOrder.length-1;j>=0;j--)\r\n                {\r\n                    setTimeout(()=> {\r\n                        const nodeInShortestPath=getShortestPathInOrder[j];\r\n                        document.getElementById(`Node -${nodeInShortestPath.row}-${nodeInShortestPath.column}`).className='Node node-shortestPath';\r\n                    },50*j);\r\n                }\r\n\r\n            },20*i);\r\n                 return;\r\n\r\n            }\r\n\r\n            setTimeout(() =>{\r\n                const node=visitedNodesInOrder[i];\r\n                \r\n                document.getElementById(`Node -${node.row}-${node.column}`).className='Node node-visited';\r\n            },20*i);\r\n\r\n        }\r\n\r\n    }\r\n\r\n \r\n\r\n\r\n    visualizeDijskhtra(){\r\n        const{grid,start,end}= this.state;\r\n        const startNode= grid[start[0]][start[1]];\r\n        const finishNode= grid[end[0]][end[1]];\r\n        const visitedNodesInOrder=dijkstra(grid,startNode,finishNode);\r\n        const getShortestPathInOrder=getNodesInShortestPath(finishNode);\r\n      \r\n        this.animateDijkstra(visitedNodesInOrder,getShortestPathInOrder);\r\n\r\n        \r\n    }\r\n\r\n    visualizeAStar(){\r\n        const{grid,start,end}= this.state;\r\n        const startNode= grid[start[0]][start[1]];\r\n        const finishNode= grid[end[0]][end[1]];\r\n        const visitedNodesInOrder=Astar(grid,startNode,finishNode);\r\n        const getShortestPathInOrder=getNodesInShortestPath(finishNode);\r\n       \r\n        this.animateDijkstra(visitedNodesInOrder,getShortestPathInOrder);\r\n\r\n        \r\n    }\r\n\r\n    visualizeDFS(){\r\n        const{grid,start,end}= this.state;\r\n        const startNode= grid[start[0]][start[1]];\r\n        const finishNode= grid[end[0]][end[1]];\r\n        const visitedNodesInOrder=dfs(grid,startNode,finishNode);\r\n        const getShortestPathInOrder=getNodesInShortestPath(finishNode);\r\n       \r\n       this.animateDijkstra(visitedNodesInOrder,getShortestPathInOrder);\r\n\r\n        \r\n    }   \r\n\r\n    visualizeBFS(){\r\n        const{grid,start,end}= this.state;\r\n        const startNode= grid[start[0]][start[1]];\r\n        const finishNode= grid[end[0]][end[1]];\r\n        const visitedNodesInOrder=bfs(grid,startNode,finishNode);\r\n        const getShortestPathInOrder=getNodesInShortestPath(finishNode);\r\n        \r\n       this.animateDijkstra(visitedNodesInOrder,getShortestPathInOrder);\r\n\r\n\r\n    }\r\n\r\n    visualizeBidirectional(){\r\n\r\n        const{grid,start,end}=this.state;\r\n        \r\n        const startNode= grid[start[0]][start[1]];\r\n        const finishNode= grid[end[0]][end[1]];\r\n        const visitedNodesInOrder=bidirectional(grid,startNode,finishNode);\r\n        const getShortestPathInOrder=getBiPath(startNode,finishNode,visitedNodesInOrder);\r\n        this.animateDijkstra(visitedNodesInOrder,getShortestPathInOrder);\r\n       \r\n\r\n    }\r\n    \r\n    \r\n\r\n    render(){\r\n        const {grid,mouseIsPressed,start,end}= this.state;\r\n\r\n       \r\n\r\n        return (\r\n\r\n    <div>\r\n            <div className=\"navbar\">\r\n                <h1>Path Visualizer</h1>\r\n                <hr/>\r\n            <form onSubmit={this.handleSubmit} className=\"dropdown\">\r\n            <label>\r\n                Pick Your favourite Algorithm:\r\n                <select value ={this.state.algoValue} onChange={this.handleChange}>\r\n                    <option value=\"dijkshtra\">Dijkstra Search</option>\r\n                    <option value=\"dfs\">Depth First Search</option>\r\n                    <option value=\"bfs\">Breadth First Search</option>\r\n                    <option value=\"AStar\">AStar Search</option>\r\n                    <option value=\"Bidirectional\">Bidirectional Search</option>\r\n                    </select>\r\n            </label>\r\n            \r\n                <input type=\"submit\" value =\"Submit\" />\r\n            </form>\r\n\r\n            </div>\r\n            <br/>\r\n\r\n        <button className=\"button\" onClick={()=> this.clearGrid(this)}>CLear Board</button>\r\n       \r\n        \r\n        \r\n        \r\n        <div className=\"grid\">\r\n            { grid.map((row,rowIdx)=>{\r\n                \r\n               \r\n                return(\r\n                    <div className=\"row\" key={rowIdx}>\r\n                        {\r\n                             row.map((node,nodeIdx)=>{\r\n\r\n                                const {row,column,isWall,isVisited}=node;\r\n                                return(\r\n                                    <Node\r\n                                        key={nodeIdx}\r\n                                        column={column}\r\n                                        row={row}\r\n                                        isFinish={end[0]===row && end[1]===column}\r\n                                        isWall={isWall}\r\n                                        isStart={start[0] ===row && start[1]===column}\r\n                                        isVisited={isVisited}\r\n                                        mouseIsPressed={mouseIsPressed}\r\n                                        onMouseDown={(row,column)=> this.handleMouseDown(row,column)}\r\n                                        onMouseEnter={(row,column)=> this.handleMouseEnter(row,column)}\r\n                                        onMouseUp={(row,column)=> this.handleMouseUp(row,column)}\r\n                                        >\r\n                                    </Node>\r\n                                        \r\n                                   \r\n                                );\r\n                            })\r\n                            \r\n                        }\r\n                       \r\n                       \r\n                    </div> \r\n                    \r\n                );\r\n\r\n            })\r\n            }   \r\n        </div>\r\n    </div> \r\n        );\r\n    }\r\n \r\n}\r\n\r\n\r\nconst getInitialGrid=() =>{\r\n\r\nconst grid=[];\r\n\r\nfor(let row=0;row<15;row++){\r\n    const currentRow=[];\r\n    for(let column=0;column<28;column++){\r\n\r\n        currentRow.push(createNode(column,row));\r\n\r\n    }\r\n\r\n    grid.push(currentRow);\r\n}\r\n\r\nreturn grid;\r\n}\r\n\r\nconst createNode=(column,row)=>{\r\n   \r\n    return{\r\n    \r\n        column,\r\n        row,\r\n        isStart:false,\r\n        isFinish:false,\r\n        distance:Infinity,\r\n        isVisited:false,\r\n        isWall:false,\r\n        previousNode:null,\r\n        fscore:0,\r\n        visitedBy:null,\r\n        traceBiNode:null,\r\n        heuristic:0,\r\n    };\r\n    \r\n    }\r\n\r\n\r\n\r\nconst GetNewStartPoints=(start,row,column)=>{\r\n    const newStart=start.slice();\r\n\r\n    newStart[0]=row;\r\n    newStart[1]=column;\r\n\r\n    return newStart;\r\n}\r\n\r\n\r\nconst GetNewFinishPoints=(end,row,column)=>{\r\n\r\n    const newEnd =end.slice();\r\n\r\n    newEnd[0]=row;\r\n    newEnd[1]=column;\r\n\r\n    return newEnd;\r\n}\r\n\r\n\r\nconst GetNewWallsGrid=(grid,row,column)=>{\r\nconst newGrid=grid.slice();\r\n\r\nconst node=newGrid[row][column];\r\n\r\nconst newNode = {\r\n\r\n    ...node,\r\n    isWall:!node.isWall,\r\n}\r\n\r\nnewGrid[row][column]=newNode;\r\nreturn newGrid;\r\n\r\n}\r\n\r\nexport default PathFindingVisulaizer;","import React from 'react';\nimport PathFindingVisulaizer from './PathFindingVisualizer/PathFindingVisualizer'\n\n\nfunction App()\n{\n  return (\n    <div className=\"App\">\n        <PathFindingVisulaizer/> \n    </div>\n  );\n}\n\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(<App />, document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}